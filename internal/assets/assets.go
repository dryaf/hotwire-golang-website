package assets

import (
	"fmt"
	"path"
	"time"

	"github.com/evanw/esbuild/pkg/api"
	"github.com/labstack/echo/v4"
	"github.com/rs/zerolog/log"
)

// BundlerConfig asset bundler configuration which provides the bare minimum to keep things simple
type BundlerConfig struct {
	EntryPoints []string
	Outfile     string
	Sourcemap   api.SourceMap
}

// BundlerWithConfig provide bundle files which are built on startup
func BundlerWithConfig(cfg BundlerConfig) echo.MiddlewareFunc {

	if len(cfg.EntryPoints) == 0 {
		log.Fatal().Msg("failed to load bundler with config no entry points provided")
	}

	if cfg.Outfile == "" {
		cfg.Outfile = "bundle.js"
	}

	start := time.Now()

	result := api.Build(api.BuildOptions{
		Banner:            `/* generated by hotwire-golang-website */`,
		Bundle:            true,
		EntryPoints:       cfg.EntryPoints,
		Outfile:           cfg.Outfile,
		MinifyWhitespace:  true,
		MinifyIdentifiers: true,
		MinifySyntax:      true,
		Sourcemap:         cfg.Sourcemap,
		Define: map[string]string{
			"process.env.NODE_ENV": `"production"`,
		},
	})

	log.Info().Str("duration", time.Since(start).String()).Msg("asset build")

	if len(result.Errors) > 0 {
		log.Fatal().Fields(map[string]interface{}{
			"errors": result.Errors,
		}).Msg("failed to build assets")
	}

	return func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {

			// very simplistic bundle file matching needs some more thought
			for _, f := range result.OutputFiles {

				assetPath := fmt.Sprintf("/%s", path.Base(f.Path))

				log.Ctx(c.Request().Context()).Debug().Str("path", c.Path()).Str("assetPath", assetPath).Msg("match asset outfile")
				if c.Path() == assetPath {
					return c.Blob(200, "application/javascript", f.Contents)
				}
			}

			return next(c)
		}
	}
}
